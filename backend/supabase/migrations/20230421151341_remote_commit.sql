drop trigger if exists "on_new_project" on "public"."projects";

drop trigger if exists "on_app_role_delete" on "public"."users_roles";

drop trigger if exists "on_app_role_update" on "public"."users_roles";

drop policy "Collaborators and creator can update project" on "public"."projects";

alter table "public"."organisations_actors" drop constraint "organisations_actors_actor_fkey";

alter table "public"."organisations_actors" drop constraint "organisations_actors_created_by_fkey";

alter table "public"."organisations_actors" drop constraint "organisations_actors_organisation_fkey";

alter table "public"."organisations_actors" drop constraint "organisations_actors_updated_by_fkey";

alter table "public"."organisations_actors_duty" drop constraint "organisations_actors_duty_duty_fkey";

alter table "public"."organisations_actors_duty" drop constraint "organisations_actors_duty_id_fkey";

alter table "public"."organisations_publication_status" drop constraint "organisations_publication_status_organisation_fkey";

alter table "public"."organisations_publication_status" drop constraint "organisations_publication_status_updated_by_fkey";

drop function if exists "public"."handle_project_insert"();

-- drop function if exists "public"."projects_ts"(projects);

drop function if exists "public"."protect_users_roles"();

alter table "public"."organisations_actors" drop constraint "organisations_actors_pkey";

alter table "public"."organisations_actors_duty" drop constraint "organisations_users_roles_pkey";

alter table "public"."organisations_publication_status" drop constraint "organisations_publication_status_pkey";

drop index if exists "public"."organisations_actors_pkey";

drop index if exists "public"."organisations_publication_status_pkey";

drop index if exists "public"."organisations_users_roles_pkey";

drop table "public"."organisations_actors";

drop table "public"."organisations_actors_duty";

drop table "public"."organisations_publication_status";

create table "public"."organisation_duty" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "title" text not null,
    "short_title" text
);


alter table "public"."organisation_duty" enable row level security;

create table "public"."organisation_expertise" (
    "id" bigint generated by default as identity not null,
    "title" text not null,
    "short_title" text not null,
    "description" text
);


alter table "public"."organisation_expertise" enable row level security;

create table "public"."organisations_expertises" (
    "expertise" bigint not null,
    "organisation" uuid not null
);


alter table "public"."organisations_expertises" enable row level security;

alter table "public"."organisations" add column "publication_requested_at" timestamp with time zone;

alter table "public"."organisations" add column "publication_requested" boolean not null generated always as ((publication_requested_at IS NOT NULL)) stored;

alter table "public"."organisations" add column "published_at" timestamp with time zone;

alter table "public"."organisations" add column "published" boolean not null generated always as ((published_at IS NOT NULL)) stored;

CREATE UNIQUE INDEX organisation_duty_pkey ON public.organisation_duty USING btree (id);

CREATE UNIQUE INDEX organisation_expertise_pkey ON public.organisation_expertise USING btree (id);

CREATE UNIQUE INDEX organisations_expertises_pkey ON public.organisations_expertises USING btree (expertise, organisation);

alter table "public"."organisation_duty" add constraint "organisation_duty_pkey" PRIMARY KEY using index "organisation_duty_pkey";

alter table "public"."organisation_expertise" add constraint "organisation_expertise_pkey" PRIMARY KEY using index "organisation_expertise_pkey";

alter table "public"."organisations_expertises" add constraint "organisations_expertises_pkey" PRIMARY KEY using index "organisations_expertises_pkey";

alter table "public"."organisations_expertises" add constraint "organisations_expertises_expertise_fkey" FOREIGN KEY (expertise) REFERENCES organisation_expertise(id) ON DELETE CASCADE not valid;

alter table "public"."organisations_expertises" validate constraint "organisations_expertises_expertise_fkey";

alter table "public"."organisations_expertises" add constraint "organisations_expertises_organisation_fkey" FOREIGN KEY (organisation) REFERENCES organisations(id) ON DELETE CASCADE not valid;

alter table "public"."organisations_expertises" validate constraint "organisations_expertises_organisation_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.handle_org_update()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
	begin
		if (auth.role() = 'authenticated') then
			-- Restrict publishing rights
			if (not user_has_role('admin', 'editor'))
			    and (new.published is not null)
			    and (old.published is null)
			    then
			      new.published = null;
			      new.requested= now();
			end if;
			-- Forbid modification of columns by client users
			if (
				old.id <> new.id
				or old.created_by <> new.created_by
				or old.created_at <> new.created_at
			) then
				raise exception 'Client attempted to update protected (access-restricted) columns.';
			end if;
		end if;
		return new;
	end;
$function$
;

CREATE OR REPLACE FUNCTION public.org_is_public(o_row organisations)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
	begin
		return o_row.published;
	end;
$function$
;

CREATE OR REPLACE FUNCTION public.projects_ts(p projects)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE
AS $function$
  select p.title || ' ' || p.description || ' ' || p.summary;
$function$
;

CREATE OR REPLACE FUNCTION public.restrict_users_roles()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin

     if (
    	(old.role = 'nplex'::public.app_role)
		and (
			(TG_OP = 'UPDATE')
			or ((TG_OP = 'DELETE') and (new.role != 'nplex'::public.app_role))
		)
	)
	or (
		(TG_OP = 'UPDATE')
		and (new.role = 'nplex'::public.app_role)
		and exists (
			select 1 from public.users_roles ur
			where (ur.role = 'nplex'::public.app_role) and (ur.user != new.user)
    	)
	) then
    	raise exception 'there must always be one and only one "nplex" user. user % cannot be deleted/updated and cannot have its role unset.', old.user_id;
    	return null;
    elseif (TG_OP = 'DELETE') then
   		return old;
   	else
   		return new;
	end if;

end;

$function$
;

CREATE OR REPLACE FUNCTION public.handle_project_update()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
	begin
		if (auth.role() = 'authenticated') then
			-- Restrict publishing rights
			if (not user_has_role('admin', 'editor'))
			    and (new.published is not null)
			    and (old.published is null)
			    then
			      new.published = null;
			      new.requested= now();
			end if;
			-- Forbid modification of columns by client users
			if (
				old.id <> new.id
				or old.created_by <> new.created_by
				or old.created_at <> new.created_at
			) then
				raise exception 'Client attempted to update protected (access-restricted) columns.';
			end if;
		end if;
		return new;
	end;
$function$
;

CREATE OR REPLACE FUNCTION public.org_is_public(o_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
	begin
		return exists (
			select 1 from organisations as o
  			where o.id = o_id
  			and o.published = true
  		);
	end;
$function$
;

create policy "Collaborators and creator can update project"
on "public"."projects"
as permissive
for update
to authenticated
using (authorize_project_update(projects.*))
with check (authorize_project_update(projects.*));


CREATE TRIGGER on_app_role_delete BEFORE DELETE ON public.users_roles FOR EACH ROW EXECUTE FUNCTION restrict_users_roles();

CREATE TRIGGER on_app_role_update BEFORE UPDATE ON public.users_roles FOR EACH ROW EXECUTE FUNCTION restrict_users_roles();


