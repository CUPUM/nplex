drop trigger if exists "on_app_role_delete" on "public"."users_roles";

drop trigger if exists "on_app_role_update" on "public"."users_roles";

drop policy "anyone can select notifications attributed to them" on "public"."notifications";

drop policy "only admins can insert notifications" on "public"."notifications";

drop policy "only creators or admins can delete" on "public"."notifications";

drop policy "only creators or admins can update" on "public"."notifications";

drop policy "users can delete own notifications" on "public"."users_notifications";

drop policy "users can only select notifications attached to them" on "public"."users_notifications";

alter table "public"."notifications" drop constraint "notifications_created_by_id_fkey";

alter table "public"."notifications" drop constraint "notifications_id_fkey";

alter table "public"."notifications" drop constraint "notifications_updated_by_id_fkey";

alter table "public"."project_exemplarity_indicator" drop constraint "project_exemplarity_indicator_updated_by_id_fkey";

alter table "public"."projects_usages" drop constraint "projects_secondary_usages_updated_by_id_fkey";

alter table "public"."users_notifications" drop constraint "users_notifications_notification_id_fkey";

alter table "public"."users" drop constraint "users_id_fkey";

alter table "public"."users_notifications" drop constraint "users_notifications_user_id_fkey";

alter table "public"."users_roles" drop constraint "users_roles_updated_by_id_fkey";

alter table "public"."users_roles" drop constraint "users_roles_user_id_fkey";

drop function if exists "public"."check_enforce_nplex_user"();

alter table "public"."notifications" drop constraint "notifications_pkey";

alter table "public"."users_notifications" drop constraint "users_notifications_pkey";

drop index if exists "public"."users_notifications_pkey";

drop index if exists "public"."notifications_pkey";

drop table "public"."notifications";

create table "public"."app_notifications" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "created_at" timestamp with time zone default now(),
    "title" text not null,
    "body" text not null,
    "public" boolean not null default true
);


alter table "public"."app_notifications" enable row level security;

create table "public"."user_occupation" (
    "id" bigint generated by default as identity not null,
    "title" text not null,
    "description" text,
    "short_title" text
);


alter table "public"."user_occupation" enable row level security;

alter table "public"."users" add column "occupation" bigint;

alter table "public"."users_notifications" drop column "notification_id";

alter table "public"."users_notifications" add column "id" uuid not null default extensions.uuid_generate_v4();

alter table "public"."users_notifications" add column "read" boolean not null default false;

alter table "public"."users_notifications" add column "user_role_request" uuid;

CREATE UNIQUE INDEX app_notifications_pkey ON public.app_notifications USING btree (id);

CREATE UNIQUE INDEX user_occupation_pkey ON public.user_occupation USING btree (id);

CREATE UNIQUE INDEX notifications_pkey ON public.users_notifications USING btree (id);

alter table "public"."app_notifications" add constraint "app_notifications_pkey" PRIMARY KEY using index "app_notifications_pkey";

alter table "public"."user_occupation" add constraint "user_occupation_pkey" PRIMARY KEY using index "user_occupation_pkey";

alter table "public"."users_notifications" add constraint "notifications_pkey" PRIMARY KEY using index "notifications_pkey";

alter table "public"."users" add constraint "users_occupation_fkey" FOREIGN KEY (occupation) REFERENCES user_occupation(id) ON DELETE SET NULL not valid;

alter table "public"."users" validate constraint "users_occupation_fkey";

alter table "public"."users_notifications" add constraint "users_notifications_user_role_request_fkey" FOREIGN KEY (user_role_request) REFERENCES users_roles(user_id) ON DELETE CASCADE not valid;

alter table "public"."users_notifications" validate constraint "users_notifications_user_role_request_fkey";

alter table "public"."users" add constraint "users_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."users" validate constraint "users_id_fkey";

alter table "public"."users_notifications" add constraint "users_notifications_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE not valid;

alter table "public"."users_notifications" validate constraint "users_notifications_user_id_fkey";

alter table "public"."users_roles" add constraint "users_roles_updated_by_id_fkey" FOREIGN KEY (updated_by_id) REFERENCES users(id) ON DELETE SET DEFAULT not valid;

alter table "public"."users_roles" validate constraint "users_roles_updated_by_id_fkey";

alter table "public"."users_roles" add constraint "users_roles_user_id_fkey" FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE not valid;

alter table "public"."users_roles" validate constraint "users_roles_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.projects_ts(projects)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE
AS $function$
  select $1.title || ' ' || $1.description;
$function$
;

CREATE OR REPLACE FUNCTION public.protect_users_roles()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin

     if (
    	(old.role = 'nplex'::public.app_role)
		and (
			(TG_OP = 'UPDATE')
			or ((TG_OP = 'DELETE') and (new.role != 'nplex'::public.app_role))
		)
	)
	or (
		(TG_OP = 'UPDATE')
		and (new.role = 'nplex'::public.app_role)
		and exists (
			select 1 from public.users_roles
			where (role = 'nplex'::public.app_role) and (user_id != new.user_id)
    	)
	) then
    	raise exception 'there must always be one and only one "nplex" user. user % cannot be deleted/updated and cannot have its role unset.', old.user_id;
    	return null;
    elseif (TG_OP = 'DELETE') then
   		return old;
   	else
   		return new;
	end if;

end;

$function$
;

create policy "Everyone can select user occupation"
on "public"."user_occupation"
as permissive
for select
to public
using (true);


create policy "only admins can insert notifications"
on "public"."users_notifications"
as permissive
for insert
to public
with check (user_has_role(VARIADIC ARRAY['admin'::app_role]));


create policy "only creators or admins can delete"
on "public"."users_notifications"
as permissive
for delete
to public
using ((user_has_role(VARIADIC ARRAY['admin'::app_role]) OR (user_id = auth.uid())));


create policy "only creators or admins can update"
on "public"."users_notifications"
as permissive
for update
to public
using ((user_has_role(VARIADIC ARRAY['admin'::app_role]) OR (user_id = auth.uid())))
with check ((user_has_role(VARIADIC ARRAY['admin'::app_role]) OR (user_id = auth.uid())));


CREATE TRIGGER on_app_role_delete BEFORE DELETE ON public.users_roles FOR EACH ROW EXECUTE FUNCTION protect_users_roles();

CREATE TRIGGER on_app_role_update BEFORE UPDATE ON public.users_roles FOR EACH ROW EXECUTE FUNCTION protect_users_roles();


