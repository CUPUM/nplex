drop policy "anyone can select" on "public"."project_event_subtype_by_type";

drop policy "anyone can select" on "public"."project_event_type";

drop policy "only creators or admins can delete" on "public"."users_notifications";

drop policy "only creators or admins can update" on "public"."users_notifications";

alter table "public"."project_event_subtype_by_type" drop constraint "project_event_subtype_by_type_subtype_fkey";

alter table "public"."project_event_subtype_by_type" drop constraint "project_event_subtype_by_type_type_fkey";

alter table "public"."project_event_subtype_by_type" drop constraint "project_event_type_subevent_type_un";

alter table "public"."project_event_type" drop constraint "project_event_type_un";

alter table "public"."projects_events" drop constraint "projects_events_type_fkey";

alter table "public"."users" drop constraint "users_updated_by_id_fkey";

alter table "public"."users_notifications" drop constraint "users_notifications_user_id_fkey";

alter table "public"."users_projects_collections" drop constraint "users_projects_collections_created_by_id_fkey";

alter table "public"."users_projects_collections" drop constraint "users_projects_collections_updated_by_id_fkey";

alter table "public"."users_projects_likes" drop constraint "users_projects_likes_project_id_fkey";

alter table "public"."users_projects_likes" drop constraint "users_projects_likes_un";

alter table "public"."users_projects_likes" drop constraint "users_projects_likes_user_id_fkey";

alter table "public"."users_projects_queries" drop constraint "users_projects_queries_created_by_id_fkey";

alter table "public"."users_projects_queries" drop constraint "users_projects_queries_updated_by_id_fkey";

drop view if exists "public"."editable_organizations";

drop view if exists "public"."random_project_images";

drop view if exists "public"."editable_actors";

drop view if exists "public"."users_session";

alter table "public"."project_event_subtype_by_type" drop constraint "project_event_subtype_by_type_pkey";

alter table "public"."project_event_type" drop constraint "project_event_type_pkey";

alter table "public"."users_projects_likes" drop constraint "users_projects_likes_pkey";

drop index if exists "public"."project_event_subtype_by_type_pkey";

drop index if exists "public"."project_event_type_pkey";

drop index if exists "public"."project_event_type_subevent_type_un";

drop index if exists "public"."project_event_type_un";

drop index if exists "public"."users_projects_likes_pkey";

drop index if exists "public"."users_projects_likes_un";

drop table "public"."project_event_subtype_by_type";

drop table "public"."project_event_type";

create table "public"."project_event" (
    "id" smallint generated by default as identity not null,
    "title" text not null,
    "description" text,
    "durative" boolean not null
);


alter table "public"."project_event" enable row level security;

create table "public"."project_subevent_by_event" (
    "event" smallint not null,
    "subevent" smallint not null
);


alter table "public"."project_subevent_by_event" enable row level security;

alter table "public"."projects_images" drop column "color_mean_hsl";

alter table "public"."projects_images" drop column "color_mean_lab";

alter table "public"."projects_images" add column "color_average_hsl" cube;

alter table "public"."projects_images" add column "color_average_lab" cube;

alter table "public"."users" drop column "updated_by_id";

alter table "public"."users" add column "updated_by" uuid not null;

alter table "public"."users_notifications" drop column "user_id";

alter table "public"."users_notifications" add column "user" uuid not null;

alter table "public"."users_projects_collections" drop column "created_by_id";

alter table "public"."users_projects_collections" drop column "updated_by_id";

alter table "public"."users_projects_collections" add column "created_by" uuid not null default default_uid();

alter table "public"."users_projects_collections" add column "updated_by" uuid default default_uid();

alter table "public"."users_projects_collections_items" drop column "collection_id";

alter table "public"."users_projects_collections_items" drop column "created_by_id";

alter table "public"."users_projects_collections_items" drop column "project_id";

alter table "public"."users_projects_collections_items" drop column "updated_by_id";

alter table "public"."users_projects_collections_items" add column "collection" uuid not null;

alter table "public"."users_projects_collections_items" add column "created_by" uuid not null default auth.uid();

alter table "public"."users_projects_collections_items" add column "project" uuid not null;

alter table "public"."users_projects_collections_items" add column "updated_by" uuid not null default default_uid();

alter table "public"."users_projects_likes" drop column "project_id";

alter table "public"."users_projects_likes" drop column "user_id";

alter table "public"."users_projects_likes" add column "project" uuid not null;

alter table "public"."users_projects_likes" add column "user" uuid not null default auth.uid();

alter table "public"."users_projects_queries" drop column "created_by_id";

alter table "public"."users_projects_queries" drop column "updated_by_id";

alter table "public"."users_projects_queries" add column "created_by" uuid not null default default_uid();

alter table "public"."users_projects_queries" add column "updated_by" uuid not null default default_uid();

CREATE UNIQUE INDEX project_event_subtype_by_type_pkey ON public.project_subevent_by_event USING btree (event, subevent);

CREATE UNIQUE INDEX project_event_type_pkey ON public.project_event USING btree (id);

CREATE UNIQUE INDEX project_event_type_subevent_type_un ON public.project_subevent_by_event USING btree (event, subevent);

CREATE UNIQUE INDEX project_event_type_un ON public.project_event USING btree (title);

CREATE UNIQUE INDEX users_projects_likes_pkey ON public.users_projects_likes USING btree (project, "user");

CREATE UNIQUE INDEX users_projects_likes_un ON public.users_projects_likes USING btree ("user", project);

alter table "public"."project_event" add constraint "project_event_type_pkey" PRIMARY KEY using index "project_event_type_pkey";

alter table "public"."project_subevent_by_event" add constraint "project_event_subtype_by_type_pkey" PRIMARY KEY using index "project_event_subtype_by_type_pkey";

alter table "public"."users_projects_likes" add constraint "users_projects_likes_pkey" PRIMARY KEY using index "users_projects_likes_pkey";

alter table "public"."project_event" add constraint "project_event_type_un" UNIQUE using index "project_event_type_un";

alter table "public"."project_subevent_by_event" add constraint "project_event_subtype_by_type_subtype_fkey" FOREIGN KEY (subevent) REFERENCES project_type(id) ON DELETE CASCADE not valid;

alter table "public"."project_subevent_by_event" validate constraint "project_event_subtype_by_type_subtype_fkey";

alter table "public"."project_subevent_by_event" add constraint "project_event_subtype_by_type_type_fkey" FOREIGN KEY (event) REFERENCES project_type(id) ON DELETE CASCADE not valid;

alter table "public"."project_subevent_by_event" validate constraint "project_event_subtype_by_type_type_fkey";

alter table "public"."project_subevent_by_event" add constraint "project_event_type_subevent_type_un" UNIQUE using index "project_event_type_subevent_type_un";

alter table "public"."projects_events" add constraint "projects_events_type_fkey" FOREIGN KEY (type) REFERENCES project_event(id) ON DELETE CASCADE not valid;

alter table "public"."projects_events" validate constraint "projects_events_type_fkey";

alter table "public"."users" add constraint "users_updated_by_id_fkey" FOREIGN KEY (updated_by) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE SET NULL not valid;

alter table "public"."users" validate constraint "users_updated_by_id_fkey";

alter table "public"."users_notifications" add constraint "users_notifications_user_id_fkey" FOREIGN KEY ("user") REFERENCES users(id) ON DELETE CASCADE not valid;

alter table "public"."users_notifications" validate constraint "users_notifications_user_id_fkey";

alter table "public"."users_projects_collections" add constraint "users_projects_collections_created_by_id_fkey" FOREIGN KEY (created_by) REFERENCES users(id) not valid;

alter table "public"."users_projects_collections" validate constraint "users_projects_collections_created_by_id_fkey";

alter table "public"."users_projects_collections" add constraint "users_projects_collections_updated_by_id_fkey" FOREIGN KEY (updated_by) REFERENCES users(id) not valid;

alter table "public"."users_projects_collections" validate constraint "users_projects_collections_updated_by_id_fkey";

alter table "public"."users_projects_likes" add constraint "users_projects_likes_project_id_fkey" FOREIGN KEY (project) REFERENCES projects(id) not valid;

alter table "public"."users_projects_likes" validate constraint "users_projects_likes_project_id_fkey";

alter table "public"."users_projects_likes" add constraint "users_projects_likes_un" UNIQUE using index "users_projects_likes_un";

alter table "public"."users_projects_likes" add constraint "users_projects_likes_user_id_fkey" FOREIGN KEY ("user") REFERENCES users(id) not valid;

alter table "public"."users_projects_likes" validate constraint "users_projects_likes_user_id_fkey";

alter table "public"."users_projects_queries" add constraint "users_projects_queries_created_by_id_fkey" FOREIGN KEY (created_by) REFERENCES users(id) not valid;

alter table "public"."users_projects_queries" validate constraint "users_projects_queries_created_by_id_fkey";

alter table "public"."users_projects_queries" add constraint "users_projects_queries_updated_by_id_fkey" FOREIGN KEY (updated_by) REFERENCES users(id) not valid;

alter table "public"."users_projects_queries" validate constraint "users_projects_queries_updated_by_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.add_project_gallery_image()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
	begin
	if (new.bucket_id = 'projects') and ((storage.foldername(new.name))[2] = 'image-gallery')
	then
		insert into public.projects_images (id, project, name, updated_by, created_by)
        values (new.id, (storage.foldername(new.name))[1]::uuid, new.name, auth.uid(), auth.uid());
		/*insert into public.projects_images as g (name, project_id, updated_by_id, created_by_id, file_names)
        values ((storage.foldername(new.name))[3]::text, (storage.foldername(new.name))[1]::uuid, auth.uid(), auth.uid(), array[new.name])
        on conflict (name) do update set
        file_names = array_append(g.file_names, new.name);*/
end if;

return new;
end;

$function$
;

CREATE OR REPLACE FUNCTION public.authorize(VARIADIC allowed_permissions text[])
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  bind_permissions int;
begin
  select count(*)
  from public.role_permissions
  inner join public.users_roles on role_permissions.role = users_roles.role
  where role_permissions.permission = any (allowed_permissions)
    and users_roles.user = auth.uid()
  into bind_permissions;
  
  return bind_permissions > 0;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.authorize(requested_permission text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  bind_permissions int;
begin
  select count(*)
  from public.role_permissions
  inner join public.users_roles on role_permissions.role = users_roles.role
  where role_permissions.permission = authorize.requested_permission
    and users_roles.user = auth.uid()
  into bind_permissions;
  
  return bind_permissions > 0;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.authorize_actor_update(actor actors)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
	begin
		-- Allow rbac-based authotization
		if public.authorize('project_update') then return true;
		-- Creators can manage as they please (except publish)
		elseif actor.created_by = auth.uid() then return true;
		-- Check if collaborator
		else return exists (
			select 1 from public.actors_users as au
			where au.actor  = actor.id
			and au.user = auth.uid()
		);
		end if;
	end;
$function$
;

CREATE OR REPLACE FUNCTION public.authorize_actor_update(actor_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
	begin
		-- Allow rbac-based authotization
		if public.authorize('actor_update') then return true;
		-- Creators can manage as they please (except publish)
		elseif exists (
			select 1 from public.actors as a
			where a.id = actor_id
			and a.created_by = auth.uid()
		) then return true;
		-- Check if collaborator
		else return exists (
			select 1 from public.actors_users as au
			where au.actor  = actor_id
			and au.user = auth.uid()
		);
		end if;
	end;
$function$
;

CREATE OR REPLACE FUNCTION public.authorize_org_update(org organisations)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
	begin
		-- Allow rbac-based authotization
		if public.authorize('organisation_update') then return true;
		-- Creators can manage as they please (except publish)
		elseif org.created_by = auth.uid() then return true;
		-- Check if collaborator
		else return exists (
			select 1 from public.organisations_users as ou
			where ou.organisation = org.id
			and ou.user = auth.uid()
		);
		end if;
	end;
$function$
;

CREATE OR REPLACE FUNCTION public.authorize_org_update(org_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
	begin
		-- Allow rbac-based authotization
		if public.authorize('organisation_update') then return true;
		-- Creators can manage as they please (except publish)
		elseif exists (
			select 1 from public.organisations as o
			where o.id = org_id
			and o.created_by = auth.uid()
		) then return true;
		-- Check if collaborator
		else return exists (
			select 1 from public.organisations_users as ou
			where ou.organisation  = org_id
			and ou.user = auth.uid()
		);
		end if;
	end;
$function$
;

CREATE OR REPLACE FUNCTION public.authorize_project_update(p_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
	begin
		-- Allow rbac-based authotization
		if public.authorize('project_update') then return true;
		-- Creators can manage as they please (except publish)
		elseif exists (
			select 1 from public.projects as p
			where p.id = p_id
			and p.created_by = auth.uid()
		) then return true;
		-- Check if collaborator
		else return exists (
			select 1 from public.projects_users as pu
			where pu.project = p_id
			and pu.user = auth.uid()
		);
		end if;
	end;
$function$
;

CREATE OR REPLACE FUNCTION public.authorize_project_update(p_row projects)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
	begin
		-- Allow rbac-based authotization
		if public.authorize('project_update') then return true;
		-- Creators can manage as they please (except publish)
		elseif p_row.created_by = auth.uid() then return true;
		-- Check if collaborator
		else return exists (
			select 1 from public.projects_users as pu
			where pu.project = p_row.id
			and pu.user = auth.uid()
		);
		end if;
	end;
$function$
;

create or replace view "public"."editable_actors" as  SELECT a.id,
    a.created_at,
    a.updated_at,
    a.created_by,
    a.updated_by,
    a.first_name,
    a.last_name,
    a.middle_name,
    a.about
   FROM actors a
  WHERE authorize_actor_update(a.*);


CREATE OR REPLACE FUNCTION public.get_relegate_uid()
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin

    return (
        select (user) from public.users_roles
        where role = 'nplex'::public.app_role
        limit 1
    );

end;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_project()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin

    insert into public.projects_publication_status (project)
    values (new.id);
   	insert into public.projects_location (project)
   	values (new.id);

    return new;

end;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin

    if not exists (
        select 1 from public.users_roles as ur
        where ur.role = 'nplex'::public.app_role
    ) then
        -- percolate auth signup to users and users_roles, while making sure the first user registered is 'nplex'
        -- with role 'nplex' to handle author right relegation on further user profile deletions.
        insert into public.users (id, first_name, updated_by)
        values (new.id, 'nplex'::text, new.id);
        insert into public.users_roles (user_id, role, updated_by)
        values (new.id, 'nplex'::public.app_role, new.id);
        -- raise notice 'the created user with id % was attributed the "nplex" lead role to fullfill required profile', new.id;
    elseif char_length(coalesce(new.raw_user_meta_data->>'first_name', '')) = 0 then
    	raise exception 'first name is required';
    else
        insert into public.users (id, first_name, last_name, updated_by)
        values (new.id, coalesce(new.raw_user_meta_data->>'first_name', null), coalesce(new.raw_user_meta_data->>'last_name', null), new.id);
        insert into public.users_roles (user_id, updated_by)
        values (new.id, new.id);
    end if;

    return new;

end;
$function$
;

CREATE OR REPLACE FUNCTION public.project_descriptors()
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
    return (
        select json_build_object(
            'types', (
                select coalesce(json_agg(row_to_json(ft)), '[]'::json)
				from (
					select t.*, coalesce(array_agg(ip) filter(where ip is not null), '{}') as interventions
					from public.project_type t
					left join (
						select ti.type, i.*
						from public.project_intervention_by_type ti
						left join public.project_intervention i
						on ti.intervention = i.id
					) ip
					on ip.type = t.id
					group by t.id
				) ft
            ),
            'interventionCategories', (
            	select coalesce(json_agg(row_to_json(ic)), '[]'::json)
            	from (
            		select *
            		from public.project_intervention_category
            		order by title asc
            	) ic
            ),
           'interventions', (
                select coalesce(json_agg(row_to_json(pti)), '[]'::json)
                from (
                    select i.*, coalesce(array_agg(ti.type) filter (where ti is not null), '{}') as types_ids
                    from public.project_intervention i
                    left join public.project_intervention_by_type ti
                    on ti.intervention = i.id
                    group by i.id
                    order by i.title asc
                ) pti
            ),
            'siteOwnerships', (
                select coalesce(json_agg(row_to_json(so)), '[]'::json)
                from (
                	select *
                	from public.project_site_ownership
               		order by title asc
               	) so
            ),
            'siteUsagesCategories', (
                select coalesce(json_agg(row_to_json(suc)), '[]'::json)
                from (
                	select *
                	from public.project_site_usage_category
                	order by title asc
                ) suc
            ),
            'siteUsages', (
                select coalesce(json_agg(row_to_json(susupc)), '[]'::json)
                from (
                    select su.*, coalesce(array_agg(supc.category) filter (where supc is not null), '{}') as category_ids
                    from public.project_site_usage su
                    left join public.project_site_usage_by_category supc
                    on supc.usage = su.id
                    group by su.id
                    order by su.title asc
                ) susupc
            ),
            'implantationModes', (
                select coalesce(json_agg(row_to_json(im)), '[]'::json)
                from (
                	select *
                	from public.project_implantation_mode
                	order by title asc
                ) im
            ),
            'materialOrigins', (
                select coalesce(json_agg(row_to_json(mo)), '[]'::json)
                from (
                	select *
                	from public.project_material_origin
                	order by title asc
                ) mo
            ),
            'materialTypes', (
                select coalesce(json_agg(row_to_json(mt)), '[]'::json)
                from (
                	select *
                	from public.project_material_type
                	order by title asc
                ) mt
            ),
            'materialUses', (
                select coalesce(json_agg(row_to_json(mu)), '[]'::json)
                from (
                	select *
                	from public.project_material_use
                	order by title asc
                ) mu
            ),
            'eventTypes', (
                select coalesce(json_agg(row_to_json(eseby)), '[]'::json)
                from (
                    select e.*, coalesce(array_agg(seby.subevent) filter (where seby is not null), '{}') as subevent_ids  
                    from public.project_event e
                    left join public.project_subevent_by_event seby
                    on seby.event = e.id
                    group by e.id
                    order by e.title asc
                ) eseby
            ),
            'exemplarityIndicatorsCategories', (
                select coalesce(json_agg(row_to_json(ecei)), '[]'::json)
                from (
                    select ec.*, coalesce(array_agg(ei.*) filter (where ei is not null), '{}') as exemplarity_indicator_ids
                    from public.project_exemplarity_category ec
                    full join (
                    	select *
                    	from public.project_exemplarity_indicator
                    	order by title asc
                    ) ei
                    on ei.category = ec.id
                    group by ec.id
                    order by ec.title asc
                ) ecei
            ),
            'exemplarityIndicators', (
                select coalesce(json_agg(row_to_json(ei)), '[]'::json)
                from (
                	select *
                	from public.project_exemplarity_indicator
                	order by title asc
                ) ei
            )
        )
    );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.project_is_public(p_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
	begin
		return exists (
			select 1 from projects_publication_status as pps
  			where pps.project = p_id
  			and pps.status = 'published'::publication_status
  		);
	end;
$function$
;

CREATE OR REPLACE FUNCTION public.protect_users_roles()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin

     if (
    	(old.role = 'nplex'::public.app_role)
		and (
			(TG_OP = 'UPDATE')
			or ((TG_OP = 'DELETE') and (new.role != 'nplex'::public.app_role))
		)
	)
	or (
		(TG_OP = 'UPDATE')
		and (new.role = 'nplex'::public.app_role)
		and exists (
			select 1 from public.users_roles
			where (role = 'nplex'::public.app_role) and (user != new.user)
    	)
	) then
    	raise exception 'there must always be one and only one "nplex" user. user % cannot be deleted/updated and cannot have its role unset.', old.user_id;
    	return null;
    elseif (TG_OP = 'DELETE') then
   		return old;
   	else
   		return new;
	end if;

end;

$function$
;

CREATE OR REPLACE FUNCTION public.track_update()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
	pre jsonb := to_jsonb(old);
	post jsonb := to_jsonb(new);
	column_names text[] := tg_argv[0]::text[];
begin
    if (post ? 'updated_at')
    and (post ? 'updated_by')
	and exists(
	    select 1
	    from jsonb_each(pre) as pre_each, jsonb_each(post) as post_each
	    where pre_each.key = post_each.key and pre_each.value is distinct from post_each.value
	    and pre_each.key = any(column_names)
    ) then
        new.updated_at = now();
       	new.updated_by = default_uid();
    end if;
	return new;   
end;
$function$
;

CREATE OR REPLACE FUNCTION public.user_has_role(VARIADIC roles app_role[])
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin

    if auth.uid() = null then return false;

    else return exists (
        select 1
        from public.users_roles as pur
        where pur.user = auth.uid()
            and pur.role = any (roles)
    );

    end if;

end;
$function$
;

CREATE OR REPLACE FUNCTION public.user_has_role(role app_role)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
#variable_conflict use_variable
begin

    if auth.uid() = null then return false;

    else return exists (
        select 1
        from public.users_roles as pur
        where pur.user = auth.uid()
            and pur.role = role
    );

    end if;

end;
$function$
;

create or replace view "public"."users_session" as  SELECT u.id,
    u.avatar_url,
    u.public_email,
    u.first_name,
    u.last_name,
    rd.role,
    rd.description AS role_description,
    rd.title AS role_title
   FROM ((users u
     JOIN users_roles r ON ((r."user" = u.id)))
     JOIN role_details rd ON ((rd.role = r.role)));


create or replace view "public"."editable_organisations" as  SELECT o.id,
    o.created_at,
    o.created_by,
    o.updated_at,
    o.updated_by,
    o.name,
    o.short_name,
    o.about
   FROM organisations o
  WHERE authorize_org_update(o.id);


create or replace view "public"."random_projects_images" as  SELECT p.title AS project_title,
    pi.created_at,
    pi.updated_at,
    pi.created_by,
    pi.updated_by,
    pi.title,
    pi.description,
    pi.index,
    pi.project,
    pi.storage_name,
    pi.id,
    pi.color_dominant_hsl,
    pi.color_dominant_lab,
    pi.color_average_hsl,
    pi.color_average_lab,
    pi.temporality,
    pi.type
   FROM (projects p
     RIGHT JOIN projects_images pi ON ((pi.project = p.id)))
  WHERE project_is_public(p.id)
  ORDER BY (random());


create policy "anyone can select"
on "public"."project_event"
as permissive
for select
to public
using (true);


create policy "anyone can select"
on "public"."project_subevent_by_event"
as permissive
for select
to public
using (true);


create policy "only creators or admins can delete"
on "public"."users_notifications"
as permissive
for delete
to public
using ((user_has_role(VARIADIC ARRAY['admin'::app_role]) OR ("user" = auth.uid())));


create policy "only creators or admins can update"
on "public"."users_notifications"
as permissive
for update
to public
using ((user_has_role(VARIADIC ARRAY['admin'::app_role]) OR ("user" = auth.uid())))
with check ((user_has_role(VARIADIC ARRAY['admin'::app_role]) OR ("user" = auth.uid())));



