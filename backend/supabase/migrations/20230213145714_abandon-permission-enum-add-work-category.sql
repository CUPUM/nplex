drop policy "anyone can select" on "public"."project_work";

drop policy "editors and admin can manage global project works" on "public"."project_work";

drop function if exists "public"."authorize"(VARIADIC allowed_permissions app_permission[]);

drop function if exists "public"."authorize"(requested_permission app_permission);

create table "public"."project_work_category" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "title" text not null,
    "description" text,
    "label" text not null
);

drop view public.editable_projects;

alter table "public"."project_work_category" enable row level security;

alter table "public"."project_work" add column "category_id" bigint;

alter table "public"."role_permissions" alter column "permission" set data type text using "permission"::text;

drop type "public"."app_permission";

CREATE UNIQUE INDEX project_work_classification_pkey ON public.project_work_category USING btree (id);

alter table "public"."project_work_category" add constraint "project_work_classification_pkey" PRIMARY KEY using index "project_work_classification_pkey";

alter table "public"."project_work" add constraint "project_work_category_id_fkey" FOREIGN KEY (category_id) REFERENCES project_work_category(id) not valid;

alter table "public"."project_work" validate constraint "project_work_category_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.authorize(VARIADIC allowed_permissions text[])
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  bind_permissions int;
begin
  select count(*)
  from public.role_permissions
  inner join public.users_roles on role_permissions.role = users_roles.role
  where role_permissions.permission = any (allowed_permissions)
    and users_roles.user_id = auth.uid()
  into bind_permissions;
  
  return bind_permissions > 0;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.authorize(requested_permission text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  bind_permissions int;
begin
  select count(*)
  from public.role_permissions
  inner join public.users_roles on role_permissions.role = users_roles.role
  where role_permissions.permission = authorize.requested_permission
    and users_roles.user_id = auth.uid()
  into bind_permissions;
  
  return bind_permissions > 0;
end;
$function$
;

create policy "Anyone can select"
on "public"."project_work"
as permissive
for select
to public
using (true);


create policy "Authorize project work delete"
on "public"."project_work"
as permissive
for delete
to public
using (authorize('descriptors_delete'::text));


create policy "Authorize project work insert"
on "public"."project_work"
as permissive
for insert
to public
with check (authorize('descriptors_insert'::text));


create policy "Authorize project work update"
on "public"."project_work"
as permissive
for update
to public
using (authorize('descriptors_update'::text))
with check (authorize('descriptors_update'::text));


create policy "Anyone can select project work classifications"
on "public"."project_work_category"
as permissive
for select
to public
using (true);


create policy "Authorize delete"
on "public"."project_work_category"
as permissive
for delete
to public
using (authorize('descriptors_delete'::text));


create policy "Authorize insert"
on "public"."project_work_category"
as permissive
for insert
to public
with check (authorize('descriptors_insert'::text));


create policy "Authorize update"
on "public"."project_work_category"
as permissive
for update
to public
using (authorize('descriptors_update'::text))
with check (authorize('descriptors_update'::text));



